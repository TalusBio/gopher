{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Gopher: Fast GO Enrichment for Quantitative Proteomic Data","text":"<p>Gopher uses a Mann-Whitney U Test to look for enriched gene ontology terms that are present when proteins are ranked by a quantitative value, such as the fold change between two conditions or the abundance of the protein.</p> <p></p>"},{"location":"#installation","title":"Installation","text":"<p>Gopher be pip installed using:</p> <pre><code>pip install gopher-enrich\n</code></pre>"},{"location":"api/","title":"API","text":""},{"location":"api/#gopher.read_encyclopedia","title":"<code>gopher.read_encyclopedia(proteins_txt)</code>","text":"<p>Read results from EncyclopeDIA.</p> PARAMETER DESCRIPTION <code>proteins_txt</code> <p>The EncyclopeDIA protein output.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>The EncyclopeDIA results in a format for gopher.</p>"},{"location":"api/#gopher.read_metamorpheus","title":"<code>gopher.read_metamorpheus(proteins_txt)</code>","text":"<p>Read results from Metamorpheus.</p> PARAMETER DESCRIPTION <code>proteins_txt</code> <p>The Metamorpheus protein output file.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>The Metamorpheus results in a format for gopher.</p>"},{"location":"api/#gopher.test_enrichment","title":"<code>gopher.test_enrichment(proteins, desc=True, aspect='all', species='human', release='current', go_subset=None, contaminants_filter=None, fetch=False, progress=False, annotations=None, mapping=None, aggregate_terms=True, alternative='greater')</code>","text":"<p>Test for the enrichment of Gene Ontology terms from protein abundance.</p> <p>The Mann-Whitney U Test is applied to each column of proteins dataframe and for each Gene Ontology (GO) term. The p-values are then corrected for multiple hypothesis testing across all of the columns using the Benjamini-Hochberg procedure.</p> PARAMETER DESCRIPTION <code>proteins</code> <p>A dataframe where the indices are UniProt accessions and each column is an experiment to test. The values in this dataframe should be some measure of protein abundance: these could be the raw measurement if originating from a single sample or a fold-change/p-value if looking at the difference between two conditions.</p> <p> TYPE: <code>DataFrame</code> </p> <code>desc</code> <p>Rank proteins in descending order?</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>aspect</code> <p>The Gene Ontology aspect to use. Use \u201ccc\u201d for \u201cCellular Compartment\u201d, \u201cmf\u201d for \u201cMolecular Function\u201d, \u201cbp\u201d for \u201cBiological Process\u201d, or \u201call\u201d for all three.</p> <p> TYPE: <code>(str, {cc, mf, bp, all})</code> DEFAULT: <code>'all'</code> </p> <code>species</code> <p>The species for which to retrieve GO annotations. If not \u201chuman\u201d or \u201cyeast\u201d, see here.</p> <p> TYPE: <code>str, {\"human\", \"yeast\", ...}, optional.</code> DEFAULT: <code>'human'</code> </p> <code>release</code> <p>The Gene Ontology release version. Using \u201ccurrent\u201d will look up the most current version.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'current'</code> </p> <code>go_subset</code> <p>The go terms of interest. Should consists of the go term names such as \u2018nucleus\u2019 or \u2018cytoplasm\u2019.</p> <p> TYPE: <code>list</code> DEFAULT: <code>None</code> </p> <code>contaminants_filter</code> <p>A list of uniprot accessions for common contaminants such as Keratin to filter out.</p> <p> TYPE: <code>list</code> DEFAULT: <code>None</code> </p> <code>fetch</code> <p>Download the GO annotations even if they have been downloaded before?</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>progress</code> <p>Show a progress bar during enrichment tests?</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>annotations</code> <p>A custom annotations dataframe.</p> <p> TYPE: <code>DataFrame</code> DEFAULT: <code>None</code> </p> <code>mapping</code> <p>A custom mapping of the GO term relationships.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>None</code> </p> <code>aggregate_terms</code> <p>Aggregate the terms and do the graph search.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>alternative</code> <p>Type of test that should be run. Could be \u201cgreater\u201d, \u201cless\u201d, or \u201ctwo-sided\u201d.</p> <p> TYPE: <code>str, {\"greater\", \"less\", \"two-sided\"} optional</code> DEFAULT: <code>'greater'</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>The adjusted p-value for each tested GO term in each sample.</p>"},{"location":"api/#gopher.get_data_dir","title":"<code>gopher.get_data_dir()</code>","text":"<p>Retrieve the current data directory for ppx.</p>"},{"location":"api/#gopher.set_data_dir","title":"<code>gopher.set_data_dir(path=None)</code>","text":"<p>Set the ppx data directory.</p> PARAMETER DESCRIPTION <code>path</code> <p>The path for ppx to use as its data directory.</p> <p> TYPE: <code>str or pathlib.Path object</code> DEFAULT: <code>None</code> </p>"},{"location":"api/#gopher.generate_annotations","title":"<code>gopher.generate_annotations(proteins, aspect, go_name, go_id=None)</code>","text":"<p>Generate an annotation file for a list of proteins that are correlated to a single term and aspect.</p> <p>The term can be in the GO database or a new term.</p> PARAMETER DESCRIPTION <code>proteins</code> <p>List of proteins (UniProtKB accessions) that will be annotated to a term.</p> <p> TYPE: <code>List[str]</code> </p> <code>aspect</code> <p>String specifying the aspect the term is in (\u201cC\u201d, \u201cF\u201d, \u201cP\u201d).</p> <p> TYPE: <code>str</code> </p> <code>go_name</code> <p>String of the GO name for the proteins</p> <p> TYPE: <code>str</code> </p> <code>go_id</code> <p>String of the GO ID. If in the GO database, the go id and go name should match the database.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>An annotations dataframe with a single go term.</p>"},{"location":"api/#gopher.load_annotations","title":"<code>gopher.load_annotations(species, aspect='all', release='current', fetch=False)</code>","text":"<p>Load the Gene Ontology (GO) annotations for a species.</p> PARAMETER DESCRIPTION <code>species</code> <p>The species for which to retrieve GO annotations. If not \u201chumnan\u201d or \u201cyeast\u201d, see here.</p> <p> TYPE: <code>(str, {human, yeast, ...})</code> </p> <code>aspect</code> <p>The Gene Ontology aspect to use. Use \u201cc\u201d for \u201cCellular Compartment\u201d, \u201cf\u201d for \u201cMolecular Function\u201d, or \u201cp\u201d for \u201cBiological Process\u201d. <code>None</code> uses all of the them.</p> <p> TYPE: <code>(str, {cc, mf, bp, all})</code> DEFAULT: <code>'all'</code> </p> <code>release</code> <p>The Gene Ontology release version. Using \u201ccurrent\u201d will look up the most current version.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'current'</code> </p> <code>fetch</code> <p>Download the file even if it already exists?</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>The annotation dataframe.</p> <code>dict</code> <p>A mapping of GO terms (keys) to Uniprot accessions with that annotation.</p>"},{"location":"api/#gopher.get_annotations","title":"<code>gopher.get_annotations(proteins, aspect='all', species='human', release='current', fetch=False, go_subset=None)</code>","text":"<p>Gets the annotations for proteins in a dataset</p> PARAMETER DESCRIPTION <code>proteins</code> <p>Dataframe of proteins and quantifications</p> <p> TYPE: <code>DataFrame</code> </p> <code>aspect</code> <p>The Gene Ontology aspect to use. Use \u201ccc\u201d for \u201cCellular Compartment\u201d, \u201cmf\u201d for \u201cMolecular Function\u201d, \u201cbp\u201d for \u201cBiological Process\u201d, or \u201call\u201d for all three.</p> <p> TYPE: <code>(str, {cc, mf, bp, all})</code> DEFAULT: <code>'all'</code> </p> <code>species</code> <p>The species for which to retrieve GO annotations. If not \u201chuman\u201d or \u201cyeast\u201d, see here.</p> <p> TYPE: <code>str, {\"human\", \"yeast\", ...}, optional.</code> DEFAULT: <code>'human'</code> </p> <code>release</code> <p>The Gene Ontology release version. Using \u201ccurrent\u201d will look up the most current version.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'current'</code> </p> <code>fetch</code> <p>Download the GO annotations even if they have been downloaded before?</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>go_subset</code> <p>The go terms of interest. Should consists of the go term names such as \u2018nucleus\u2019 or \u2018cytoplasm\u2019.</p> <p> TYPE: <code>list</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>Dataframe with protein annotations</p>"},{"location":"api/#gopher.map_proteins","title":"<code>gopher.map_proteins(protein_list, aspect='all', species='human', release='current', fetch=False)</code>","text":"<p>Map the proteins to the GO terms</p> PARAMETER DESCRIPTION <code>protein_list</code> <p>A list of UniProt accessions.</p> <p> TYPE: <code>List[str]</code> </p> <code>aspect</code> <p>The Gene Ontology aspect to use. Use \u201ccc\u201d for \u201cCellular Compartment\u201d, \u201cmf\u201d for \u201cMolecular Function\u201d, \u201cbp\u201d for \u201cBiological Process\u201d, or \u201call\u201d for all three.</p> <p> TYPE: <code>(str, {cc, mf, bp, all})</code> DEFAULT: <code>'all'</code> </p> <code>species</code> <p>The species for which to retrieve GO annotations. If not \u201chuman\u201d or \u201cyeast\u201d, see here.</p> <p> TYPE: <code>str, {\"human\", \"yeast\", ...}, optional.</code> DEFAULT: <code>'human'</code> </p> <code>release</code> <p>The Gene Ontology release version. Using \u201ccurrent\u201d will look up the most current version.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'current'</code> </p> <code>fetch</code> <p>Download the GO annotations even if they have been downloaded before?</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>Dataframe with protein accessions and GO terms</p>"},{"location":"api/#gopher.normalize_values","title":"<code>gopher.normalize_values(proteins, fasta)</code>","text":"<p>Normalize intensity values.</p> <p>Normalize using the proteomic ruler approach outlined by Wi\u015bniewski et al. (doi: https://doi.org/10.1074/mcp.M113.037309)</p> PARAMETER DESCRIPTION <code>proteins</code> <p>A dataframe where the indices are UniProt accessions and each column is an experiment to test. The values in this dataframe raw protein abundance</p> <p> TYPE: <code>DataFrame</code> </p> <code>fasta</code> <p>Use the FASTA file to generate molecular weights for normalization</p> <p> TYPE: <code>Path</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>The normalized intensities for every protein in each sample.</p>"},{"location":"api/#gopher.get_rankings","title":"<code>gopher.get_rankings(proteins, go_term, aspect='all', species='human', release='current', fetch=False)</code>","text":"<p>Rank the proteins and show whether proteins are in a specified term</p> PARAMETER DESCRIPTION <code>proteins</code> <p>Dataframe of protein quant data</p> <p> TYPE: <code>DataFrame</code> </p> <code>go_term</code> <p>String of specified GO term name</p> <p> TYPE: <code>str</code> </p> <code>aspect</code> <p>The Gene Ontology aspect to use. Use \u201ccc\u201d for \u201cCellular Compartment\u201d, \u201cmf\u201d for \u201cMolecular Function\u201d, \u201cbp\u201d for \u201cBiological Process\u201d, or \u201call\u201d for all three.</p> <p> TYPE: <code>(str, {cc, mf, bp, all})</code> DEFAULT: <code>'all'</code> </p> <code>species</code> <p>The species for which to retrieve GO annotations. If not \u201chuman\u201d or \u201cyeast\u201d, see here.</p> <p> TYPE: <code>str, {\"human\", \"yeast\", ...}, optional.</code> DEFAULT: <code>'human'</code> </p> <code>release</code> <p>The Gene Ontology release version. Using \u201ccurrent\u201d will look up the most current version.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'current'</code> </p> <code>fetch</code> <p>Download the GO annotations even if they have been downloaded before?</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>Dataframe with protein rankings and whether or not the protein is in the specified term</p>"},{"location":"api/#gopher.in_term","title":"<code>gopher.in_term(proteins, go_term, annot)</code>","text":"<p>See if proteins are associated with a specific term</p> PARAMETER DESCRIPTION <code>proteins</code> <p>Dataframe of proteins and quantifications</p> <p> TYPE: <code>DataFrame</code> </p> <code>go_term</code> <p>String of specified GO term name</p> <p> TYPE: <code>str</code> </p> <code>annot</code> <p>Annotation file for the dataset</p> <p> TYPE: <code>DataFrame</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>Dataframe with protein quant and if protein is in the given term</p>"},{"location":"api/#gopher.roc","title":"<code>gopher.roc(proteins, go_term, aspect='all', species='human', release='current', fetch=False)</code>","text":"<p>Plot the ROC curve for a go term in each sample</p> PARAMETER DESCRIPTION <code>proteins</code> <p>Dataframe of proteins and quantifications</p> <p> TYPE: <code>DataFrame</code> </p> <code>go_term</code> <p>String of specified GO term name</p> <p> TYPE: <code>str</code> </p> <code>aspect</code> <p>The Gene Ontology aspect to use. Use \u201ccc\u201d for \u201cCellular Compartment\u201d, \u201cmf\u201d for \u201cMolecular Function\u201d, \u201cbp\u201d for \u201cBiological Process\u201d, or \u201call\u201d for all three.</p> <p> TYPE: <code>(str, {cc, mf, bp, all})</code> DEFAULT: <code>'all'</code> </p> <code>species</code> <p>The species for which to retrieve GO annotations. If not \u201chuman\u201d or \u201cyeast\u201d, see here.</p> <p> TYPE: <code>str, {\"human\", \"yeast\", ...}, optional.</code> DEFAULT: <code>'human'</code> </p> <code>release</code> <p>The Gene Ontology release version. Using \u201ccurrent\u201d will look up the most current version.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'current'</code> </p> <code>fetch</code> <p>Download the GO annotations even if they have been downloaded before?</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>pyplot</code> <p>Plot of ROC curve for a GO term</p>"},{"location":"examples/","title":"Short Examples","text":""},{"location":"examples/#basic-enrichment","title":"Basic enrichment","text":"<p>Gopher can takes a proteomic file with the UniProtKB accessions as the index and quantitative values (p-value, intensity, fold change, etc.) as the columns.</p> <p>Example input:</p> index Sample 1 Sample 2 Sample 3 P10809 3.95430112E+08 3.83382752E+08 5.11112448E+08 Q9Y6Y0 1.18023552E+09 1.24697638E+09 8.1498893E+08 \u2026 \u2026 \u2026 \u2026 <pre><code>import gopher\n\n# Perform the GO enrichment analysis:\nresults = gopher.test_enrichment(proteins=quant_proteins)\n</code></pre> <p>Gopher returns a dataframe with the following columns:</p> <ul> <li>GO ID: String with the gene ontology term ID.</li> <li>GO Name: String with the gene ontology term name.</li> <li>GO Aspect: String with the gene ontology aspect. Either C (cellular component), F (molecular function), and B (biological process).</li> <li>Columns containing p-values from the GO enrichment.</li> </ul> <p>Example output: </p> GO ID GO Name GO Aspect Sample 1 Sample 2 Sample 3 GO:0000228 nuclear chromosome C 0.1271222 0.2485581 0.1503805 GO:0005737 cytoplasm C 0.5443486 0.0049575 0.0183452 GO:0009986 cell surface C 0.9657132 0.9962968 0.9997324 \u2026 \u2026 \u2026 \u2026 \u2026 \u2026 <p>You can run an enrichment on one specific aspect:</p> <p>We have three aspects we can search, cellular component (cc), molecular function (mf), and biological process (bp). More detail on gene ontology aspects can be found here.</p> <pre><code># Perform the GO enrichment analysis searching on the cellular component aspect:\nresults = gopher.test_enrichment(proteins=quant_proteins, aspect=\"cc\")\n</code></pre> <p>Or on a subset of terms:</p> <pre><code>terms = [\n    \"cytoplasm\",\n    \"nucleus\",\n    \"cell surface\",\n    \"protein folding\",\n    \"dna repair\"\n]\n\n# Peform the GO enrichment analysis:\nresults = gopher.test_enrichment(proteins=quant_proteins, go_subset=terms)\n</code></pre> <p>If you search a subset of terms, the DAG algorithm will run to aggregate all child terms of the terms of interest.</p> <p>The DAG algorithm is a hybrid depth-first search and breadth-first search. The algorithm will find the first child of the term of interest and then find all it\u2019s children and grandchildren until it finds all descendants from than child. It will and annotate those descendants with the term of interest and go to the next child of the term of interest and repeat until all descendants have been annotated. If a child term is also a term of interest, it does not get aggregated into the other term. If two terms of interest share a child, the child is annotated by both terms.</p> <p></p> <p>You can turn this off using the <code>aggregate_terms</code> parameter. When you turn off the <code>aggregate_terms</code> parameter, gopher only searches for proteins directly associated with the term of interest.</p> <pre><code>results = gopher.test_enrichment(proteins=quant_proteins, go_subset=terms, aggregate_terms=False)\n</code></pre> <p>If using a file where the quant values are p-values, you can rank in ascending order.</p> <p>By default, gopher ranks values by descending order, larger values will have a lower rank. The ranking order can be switched by setting the <code>desc</code> parameter to <code>False</code>.</p> <pre><code>results = gopher.test_enrichment(proteins=quant_proteins, desc=False)\n</code></pre>"},{"location":"examples/#file-parsers","title":"File parsers","text":"<p>Gopher can format an encyclopeDIA and metamorpheus file for the enrichment</p> <p>The output of encyclopeDIA and metamorpheus can be directly inputed to gopher using the <code>read_encyclopedia</code> and <code>read_metamorpheus</code> functions. These functions will format the data for the enrichment.</p> <pre><code># Read data from an EncyclopeDIA output:\nproteins = gopher.read_encyclopedia(\"results.quant.elib.proteins.txt\")\n\n# Peform the GO enrichment analysis:\nresults = gopher.test_enrichment(proteins=proteins)\n</code></pre>"},{"location":"examples/#normalization","title":"Normalization","text":"<p>If raw intensities are used, you can normalize your data using the proteomic ruler approach (Wi\u015bniewski JR, et al, 2014). This approach is built off the following equations presented in the proteomic ruler paper:</p>      \\frac{Protein \\: Mass}{Total \\: Protein \\: Mass} \\approx \\frac{Protein \\: MS \\: Signal}{Total \\: MS \\: Signal}  <pre><code># Normalize the raw intensities\nnormalized_proteins = gopher.normalize_values(quant_proteins, \"human_fasta.fasta\")\n\n# Peform the GO enrichment analysis:\nresults = gopher.test_enrichment(proteins=normalized_proteins)\n</code></pre>"},{"location":"vignettes/","title":"Enrichment vignette","text":"In\u00a0[1]: Copied! <pre>import pandas as pd\nimport gopher\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport numpy as np\nimport warnings\nwarnings.filterwarnings('ignore')\n</pre> import pandas as pd import gopher import matplotlib.pyplot as plt import seaborn as sns import numpy as np import warnings warnings.filterwarnings('ignore') <p>Read the input file. This data comes from a FAK knockout dataset (Table S1) from  Koide E, et al. 2023.</p> In\u00a0[2]: Copied! <pre>df = pd.read_csv(\"static/prot_quant.txt\", sep='\\t')\ndf.head()\n</pre> df = pd.read_csv(\"static/prot_quant.txt\", sep='\\t') df.head() Out[2]: ID Protein logFC AveExpr t P.Value adj.P.Val B 0 Q05397 PTK2 -2.859883 2.340355 -99.425405 1.060000e-11 8.690000e-08 12.498542 1 Q15418-2 RPS6KA1 -0.932924 3.128221 -19.062544 5.290000e-07 1.081399e-03 6.609119 2 O14965 AURKA -0.650304 3.160873 -19.699383 4.270000e-07 1.081399e-03 6.437053 3 P51948-1 MNAT1 -0.500882 3.227122 -14.454300 3.140000e-06 5.143099e-03 4.712882 4 Q9BYT3-1 STK33 -2.075020 2.675332 -27.269400 5.150000e-08 2.106740e-04 4.557334 <p>For gopher we need to reformat the data so the index is the UniProtKB accessions and the columns are the quantitative values we want to test. Since this data has statstic information, we choose the value we want to test. I am choosing <code>ad.P.Val</code> here.</p> In\u00a0[3]: Copied! <pre>input_df = df[[\"ID\", \"adj.P.Val\"]].set_index(\"ID\")\ninput_df.head()\n</pre> input_df = df[[\"ID\", \"adj.P.Val\"]].set_index(\"ID\") input_df.head() Out[3]: adj.P.Val ID Q05397 8.690000e-08 Q15418-2 1.081399e-03 O14965 1.081399e-03 P51948-1 5.143099e-03 Q9BYT3-1 2.106740e-04 <p>Next I choose the terms I want to search. I am choosing some terms I expect to be enriched in this dataset and some that I do not expect to be enriched. This is optional, you can search all terms.</p> In\u00a0[4]: Copied! <pre>terms = [\n    # should NOT be enriched\n    \"membrane organization\",\n    \"protein folding\",\n    \"transcription regulator activity\",\n    # SHOULD be enriched\n    \"cell adhesion\",\n    \"anatomical structure development\",\n    \"cell motility\",\n    \"cell differentiation\",\n    \"protein phosphorylation\",\n    \"protein autophosphorylation\"\n]\n</pre> terms = [     # should NOT be enriched     \"membrane organization\",     \"protein folding\",     \"transcription regulator activity\",     # SHOULD be enriched     \"cell adhesion\",     \"anatomical structure development\",     \"cell motility\",     \"cell differentiation\",     \"protein phosphorylation\",     \"protein autophosphorylation\" ] <p>Run the enrichment on the data with the terms of interest. I also set the descending flag to <code>False</code> since we want the lower (more significant) p-values to be ranked lower.</p> In\u00a0[5]: Copied! <pre>results = gopher.test_enrichment(input_df, go_subset=terms, desc=False)\nresults.head()\n</pre> results = gopher.test_enrichment(input_df, go_subset=terms, desc=False) results.head() <pre>OMP: Info #276: omp_set_nested routine deprecated, please use omp_set_max_active_levels instead.\n</pre> Out[5]: GO ID GO Name GO Aspect adj.P.Val 0 GO:0006457 protein folding P 0.987289 1 GO:0006468 protein phosphorylation P 0.072794 2 GO:0007155 cell adhesion P 0.848735 3 GO:0030154 cell differentiation P 0.267482 4 GO:0046777 protein autophosphorylation P 0.069585 <p>To visualize the data, we reformat the data and plot the -log10(p-value).</p> In\u00a0[6]: Copied! <pre>long_df = results.melt(\n    [\"GO ID\", \"GO Name\", \"GO Aspect\"],\n    var_name=\"Run\",\n    value_name=\"pvalue\",\n)\nlong_df[\"neglogpval\"] = -np.log10(long_df[\"pvalue\"])\n</pre> long_df = results.melt(     [\"GO ID\", \"GO Name\", \"GO Aspect\"],     var_name=\"Run\",     value_name=\"pvalue\", ) long_df[\"neglogpval\"] = -np.log10(long_df[\"pvalue\"]) In\u00a0[7]: Copied! <pre>sns.barplot(\n    long_df.sort_values(by=\"neglogpval\"),\n    x=\"GO Name\",\n    y=\"neglogpval\",\n    hue=\"Run\",\n)\nplt.ylabel(\"-log10(pval)\")\nplt.xticks(rotation=90)\nplt.show()\n</pre> sns.barplot(     long_df.sort_values(by=\"neglogpval\"),     x=\"GO Name\",     y=\"neglogpval\",     hue=\"Run\", ) plt.ylabel(\"-log10(pval)\") plt.xticks(rotation=90) plt.show() <p>If I want to further investigate a term, I can by looking at the protein rankings of that term.</p> In\u00a0[8]: Copied! <pre>ranks = gopher.get_rankings(input_df, \"cell motility\")\nranks.head()\n</pre> ranks = gopher.get_rankings(input_df, \"cell motility\") ranks.head() Out[8]: adj.P.Val in_term ID Q05397 1.0 True Q15418-2 3.5 False P51948-1 5.0 False Q9BYT3-1 2.0 False P51946 6.0 False In\u00a0[9]: Copied! <pre>in_term = ranks[ranks[\"in_term\"]]\nsns.kdeplot(in_term[\"adj.P.Val\"], label=\"In term\")\nout_term = ranks[~ranks[\"in_term\"]]\nsns.kdeplot(out_term[\"adj.P.Val\"], label=\"Not in term\")\nplt.xlabel(\"Rankings\")\nplt.legend()\nplt.show()\n</pre> in_term = ranks[ranks[\"in_term\"]] sns.kdeplot(in_term[\"adj.P.Val\"], label=\"In term\") out_term = ranks[~ranks[\"in_term\"]] sns.kdeplot(out_term[\"adj.P.Val\"], label=\"Not in term\") plt.xlabel(\"Rankings\") plt.legend() plt.show()"},{"location":"vignettes/#enrichment-vignette","title":"Enrichment vignette\u00b6","text":"<p>First, import required packages.</p>"}]}