{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Gopher: Fast GO Enrichment for Quantitative Proteomic Data","text":"<p>Gopher uses a Mann-Whitney U Test to look for enriched gene ontology terms that are present when proteins are ranked by a quantitative value, such as the fold change between two conditions or the abundance of the protein.</p> <p></p>"},{"location":"#installation","title":"Installation","text":"<p>Gopher be pip installed using:</p> <pre><code>pip install gopher-enrich\n</code></pre>"},{"location":"api/","title":"API","text":""},{"location":"api/#gopher.read_encyclopedia","title":"<code>gopher.read_encyclopedia(proteins_txt)</code>","text":"<p>Read results from EncyclopeDIA.</p> PARAMETER DESCRIPTION <code>proteins_txt</code> <p>The EncyclopeDIA protein output.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>The EncyclopeDIA results in a format for gopher.</p>"},{"location":"api/#gopher.read_metamorpheus","title":"<code>gopher.read_metamorpheus(proteins_txt)</code>","text":"<p>Read results from Metamorpheus.</p> PARAMETER DESCRIPTION <code>proteins_txt</code> <p>The Metamorpheus protein output file.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>The Metamorpheus results in a format for gopher.</p>"},{"location":"api/#gopher.read_diann","title":"<code>gopher.read_diann(proteins_tsv)</code>","text":"<p>Reads a DIANN-generated TSV file (pg_matrix).</p> <p>Also processes it, and returns a cleaned Pandas DataFrame.</p> <p>The function: - Extracts the first protein accession from the \u201cProtein.Ids\u201d column to use     as the DataFrame index. - Renames the index axis to \u201cProtein\u201d. - Drops unnecessary metadata columns.</p> PARAMETER DESCRIPTION <code>proteins_tsv</code> <p>Path to the DIANN-generated TSV file. Expected columns:     \u2018Protein.Group\u2019,     \u2018Protein.Ids\u2019,     \u2018Protein.Names\u2019,     \u2018Genes\u2019,     \u2018First.Protein.Description\u2019,      <p> TYPE: <code>PathLike</code> </p> RETURNS DESCRIPTION <code>pd.DataFrame: A DataFrame with the processed protein data, indexed by</code> <p>the first protein accession. The returned DataFrame has the \u201cProtein.Ids\u201d column as the index and all columns are the MSR columns.</p>"},{"location":"api/#gopher.test_enrichment","title":"<code>gopher.test_enrichment(proteins, desc=True, aspect='all', species='human', release='current', go_subset=None, contaminants_filter=None, fetch=False, progress=False, annotations=None, mapping=None, aggregate_terms=True)</code>","text":"<p>Test for the enrichment of Gene Ontology terms from protein abundance.</p> <p>The Mann-Whitney U Test is applied to each column of proteins dataframe and for each Gene Ontology (GO) term. The p-values are then corrected for multiple hypothesis testing across all of the columns using the Benjamini-Hochberg procedure.</p> PARAMETER DESCRIPTION <code>proteins</code> <p>A dataframe where the indices are UniProt accessions and each column is an experiment to test. The values in this dataframe should be some measure of protein abundance: these could be the raw measurement if originating from a single sample or a fold-change/p-value if looking at the difference between two conditions.</p> <p> TYPE: <code>DataFrame</code> </p> <code>desc</code> <p>Rank proteins in descending order?</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>aspect</code> <p>The Gene Ontology aspect to use. Use \u201ccc\u201d for \u201cCellular Compartment\u201d, \u201cmf\u201d for \u201cMolecular Function\u201d, \u201cbp\u201d for \u201cBiological Process\u201d, or \u201call\u201d for all three.</p> <p> TYPE: <code>(str, {cc, mf, bp, all})</code> DEFAULT: <code>'all'</code> </p> <code>species</code> <p>The species for which to retrieve GO annotations. If not \u201chuman\u201d or \u201cyeast\u201d, see here.</p> <p> TYPE: <code>str, {\"human\", \"yeast\", ...}, optional.</code> DEFAULT: <code>'human'</code> </p> <code>release</code> <p>The Gene Ontology release version. Using \u201ccurrent\u201d will look up the most current version.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'current'</code> </p> <code>go_subset</code> <p>The go terms of interest. Should consists of the go term names such as \u2018nucleus\u2019 or \u2018cytoplasm\u2019.</p> <p> DEFAULT: <code>None</code> </p> <code>contaminants_filter</code> <p>A list of uniprot accessions for common contaminants such as Keratin to filter out.</p> <p> DEFAULT: <code>None</code> </p> <code>fetch</code> <p>Download the GO annotations even if they have been downloaded before?</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>progress</code> <p>Show a progress bar during enrichment tests?</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>annotations</code> <p>A custom annotations dataframe.</p> <p> DEFAULT: <code>None</code> </p> <code>mapping</code> <p>A custom mapping of the GO term relationships.</p> <p> DEFAULT: <code>None</code> </p> <code>aggregate_terms</code> <p>Aggregate the terms and do the tree search.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>The adjusted p-value for each tested GO term in each sample.</p>"},{"location":"api/#gopher.get_data_dir","title":"<code>gopher.get_data_dir()</code>","text":"<p>Retrieve the current data directory for ppx.</p>"},{"location":"api/#gopher.set_data_dir","title":"<code>gopher.set_data_dir(path=None)</code>","text":"<p>Set the ppx data directory.</p> PARAMETER DESCRIPTION <code>path</code> <p>The path for ppx to use as its data directory.</p> <p> TYPE: <code>str or pathlib.Path object</code> DEFAULT: <code>None</code> </p>"},{"location":"examples/","title":"Short Examples","text":""},{"location":"examples/#basic-enrichment","title":"Basic enrichment","text":"<p>Gopher can takes a proteomic file with the UniProtKB accessions as the index and quantitative values (p-value, intensity, fold change, etc.) as the columns.</p> <p>Example input:</p> index Sample 1 Sample 2 Sample 3 P10809 3.95430112E+08 3.83382752E+08 5.11112448E+08 Q9Y6Y0 1.18023552E+09 1.24697638E+09 8.1498893E+08 \u2026 \u2026 \u2026 \u2026 <pre><code>import gopher\n\n# Perform the GO enrichment analysis:\nresults = gopher.test_enrichment(proteins=quant_proteins)\n</code></pre> <p>Gopher returns a dataframe with the following columns:</p> <ul> <li>GO ID: String with the gene ontology term ID.</li> <li>GO Name: String with the gene ontology term name.</li> <li>GO Aspect: String with the gene ontology aspect. Either C (cellular component), F (molecular function), and B (biological process).</li> <li>Columns containing p-values from the GO enrichment.</li> </ul> <p>Example output:</p> GO ID GO Name GO Aspect Sample 1 Sample 2 Sample 3 GO:0000228 nuclear chromosome C 0.1271222 0.2485581 0.1503805 GO:0005737 cytoplasm C 0.5443486 0.0049575 0.0183452 GO:0009986 cell surface C 0.9657132 0.9962968 0.9997324 \u2026 \u2026 \u2026 \u2026 \u2026 \u2026 <p>You can run an enrichment on one specific aspect:</p> <p>We have three aspects we can search, cellular component (cc), molecular function (mf), and biological process (bp). More detail on gene ontology aspects can be found here.</p> <pre><code># Perform the GO enrichment analysis searching on the cellular component aspect:\nresults = gopher.test_enrichment(proteins=quant_proteins, aspect=\"cc\")\n</code></pre> <p>Or on a subset of terms:</p> <pre><code>terms = [\n    \"cytoplasm\",\n    \"nucleus\",\n    \"cell surface\",\n    \"protein folding\",\n    \"dna repair\"\n]\n\n# Peform the GO enrichment analysis:\nresults = gopher.test_enrichment(proteins=quant_proteins, go_subset=terms)\n</code></pre> <p>If you search a subset of terms, the DAG algorithm will run to aggregate all child terms of the terms of interest.</p> <p>The DAG algorithm is a hybrid depth-first search and breadth-first search. The algorithm will find the first child of the term of interest and then find all it\u2019s children and grandchildren until it finds all descendants from than child. It will and annotate those descendants with the term of interest and go to the next child of the term of interest and repeat until all descendants have been annotated. If a child term is also a term of interest, it does not get aggregated into the other term. If two terms of interest share a child, the child is annotated by both terms.</p> <p></p> <p>You can turn this off using the <code>aggregate_terms</code> parameter. When you turn off the <code>aggregate_terms</code> parameter, gopher only searches for proteins directly associated with the term of interest.</p> <pre><code>results = gopher.test_enrichment(proteins=quant_proteins, go_subset=terms, aggregate_terms=False)\n</code></pre> <p>If using a file where the quant values are p-values, you can rank in ascending order.</p> <p>By default, gopher ranks values by descending order, larger values will have a lower rank. The ranking order can be switched by setting the <code>desc</code> parameter to <code>False</code>.</p> <pre><code>results = gopher.test_enrichment(proteins=quant_proteins, desc=False)\n</code></pre>"},{"location":"examples/#file-parsers","title":"File parsers","text":"<p>Gopher can format an encyclopeDIA and metamorpheus file for the enrichment</p> <p>The output of encyclopeDIA and metamorpheus can be directly inputed to gopher using the <code>read_encyclopedia</code> and <code>read_metamorpheus</code> functions. These functions will format the data for the enrichment.</p> <pre><code># Read data from an EncyclopeDIA output:\nproteins = gopher.read_encyclopedia(\"results.quant.elib.proteins.txt\")\n\n# Peform the GO enrichment analysis:\nresults = gopher.test_enrichment(proteins=proteins)\n</code></pre>"},{"location":"examples/#normalization","title":"Normalization","text":"<p>If raw intensities are used, you can normalize your data using the proteomic ruler approach (Wi\u015bniewski JR, et al, 2014). This approach is built off the following equations presented in the proteomic ruler paper:</p>      \\frac{Protein \\: Mass}{Total \\: Protein \\: Mass} \\approx \\frac{Protein \\: MS \\: Signal}{Total \\: MS \\: Signal}  <pre><code># Normalize the raw intensities\nnormalized_proteins = gopher.normalize_values(quant_proteins, \"human_fasta.fasta\")\n\n# Peform the GO enrichment analysis:\nresults = gopher.test_enrichment(proteins=normalized_proteins)\n</code></pre>"},{"location":"vignettes/","title":"Enrichment vignette","text":"In\u00a0[1]: Copied! <pre>import warnings\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\n\nimport gopher\n\nwarnings.filterwarnings(\"ignore\")\n</pre> import warnings  import matplotlib.pyplot as plt import numpy as np import pandas as pd import seaborn as sns  import gopher  warnings.filterwarnings(\"ignore\") <p>Read the input file. This data comes from a FAK knockout dataset (Table S1) from  Koide E, et al. 2023.</p> In\u00a0[2]: Copied! <pre>df = pd.read_csv(\"static/prot_quant.txt\", sep=\"\\t\")\ndf.head()\n</pre> df = pd.read_csv(\"static/prot_quant.txt\", sep=\"\\t\") df.head() Out[2]: ID Protein logFC AveExpr t P.Value adj.P.Val B 0 Q05397 PTK2 -2.859883 2.340355 -99.425405 1.060000e-11 8.690000e-08 12.498542 1 Q15418-2 RPS6KA1 -0.932924 3.128221 -19.062544 5.290000e-07 1.081399e-03 6.609119 2 O14965 AURKA -0.650304 3.160873 -19.699383 4.270000e-07 1.081399e-03 6.437053 3 P51948-1 MNAT1 -0.500882 3.227122 -14.454300 3.140000e-06 5.143099e-03 4.712882 4 Q9BYT3-1 STK33 -2.075020 2.675332 -27.269400 5.150000e-08 2.106740e-04 4.557334 <p>For gopher we need to reformat the data so the index is the UniProtKB accessions and the columns are the quantitative values we want to test. Since this data has statstic information, we choose the value we want to test. I am choosing <code>ad.P.Val</code> here.</p> In\u00a0[3]: Copied! <pre>input_df = df[[\"ID\", \"adj.P.Val\"]].set_index(\"ID\")\ninput_df.head()\n</pre> input_df = df[[\"ID\", \"adj.P.Val\"]].set_index(\"ID\") input_df.head() Out[3]: adj.P.Val ID Q05397 8.690000e-08 Q15418-2 1.081399e-03 O14965 1.081399e-03 P51948-1 5.143099e-03 Q9BYT3-1 2.106740e-04 <p>Next I choose the terms I want to search. I am choosing some terms I expect to be enriched in this dataset and some that I do not expect to be enriched. This is optional, you can search all terms.</p> In\u00a0[4]: Copied! <pre>terms = [\n    # should NOT be enriched\n    \"membrane organization\",\n    \"protein folding\",\n    \"transcription regulator activity\",\n    # SHOULD be enriched\n    \"cell adhesion\",\n    \"anatomical structure development\",\n    \"cell motility\",\n    \"cell differentiation\",\n    \"protein phosphorylation\",\n    \"protein autophosphorylation\",\n]\n</pre> terms = [     # should NOT be enriched     \"membrane organization\",     \"protein folding\",     \"transcription regulator activity\",     # SHOULD be enriched     \"cell adhesion\",     \"anatomical structure development\",     \"cell motility\",     \"cell differentiation\",     \"protein phosphorylation\",     \"protein autophosphorylation\", ] <p>Run the enrichment on the data with the terms of interest. I also set the descending flag to <code>False</code> since we want the lower (more significant) p-values to be ranked lower.</p> In\u00a0[5]: Copied! <pre>results = gopher.test_enrichment(input_df, go_subset=terms, desc=False)\nresults.head()\n</pre> results = gopher.test_enrichment(input_df, go_subset=terms, desc=False) results.head() <pre>OMP: Info #276: omp_set_nested routine deprecated, please use omp_set_max_active_levels instead.\n</pre> Out[5]: GO ID GO Name GO Aspect adj.P.Val 0 GO:0006457 protein folding P 0.987289 1 GO:0006468 protein phosphorylation P 0.072794 2 GO:0007155 cell adhesion P 0.848735 3 GO:0030154 cell differentiation P 0.267482 4 GO:0046777 protein autophosphorylation P 0.069585 <p>To visualize the data, we reformat the data and plot the -log10(p-value).</p> In\u00a0[6]: Copied! <pre>long_df = results.melt(\n    [\"GO ID\", \"GO Name\", \"GO Aspect\"],\n    var_name=\"Run\",\n    value_name=\"pvalue\",\n)\nlong_df[\"neglogpval\"] = -np.log10(long_df[\"pvalue\"])\n</pre> long_df = results.melt(     [\"GO ID\", \"GO Name\", \"GO Aspect\"],     var_name=\"Run\",     value_name=\"pvalue\", ) long_df[\"neglogpval\"] = -np.log10(long_df[\"pvalue\"]) In\u00a0[7]: Copied! <pre>sns.barplot(\n    long_df.sort_values(by=\"neglogpval\"),\n    x=\"GO Name\",\n    y=\"neglogpval\",\n    hue=\"Run\",\n)\nplt.ylabel(\"-log10(pval)\")\nplt.xticks(rotation=90)\nplt.show()\n</pre> sns.barplot(     long_df.sort_values(by=\"neglogpval\"),     x=\"GO Name\",     y=\"neglogpval\",     hue=\"Run\", ) plt.ylabel(\"-log10(pval)\") plt.xticks(rotation=90) plt.show() <p>If I want to further investigate a term, I can by looking at the protein rankings of that term.</p> In\u00a0[8]: Copied! <pre>ranks = gopher.get_rankings(input_df, \"cell motility\")\nranks.head()\n</pre> ranks = gopher.get_rankings(input_df, \"cell motility\") ranks.head() Out[8]: adj.P.Val in_term ID Q05397 1.0 True Q15418-2 3.5 False P51948-1 5.0 False Q9BYT3-1 2.0 False P51946 6.0 False In\u00a0[9]: Copied! <pre>in_term = ranks[ranks[\"in_term\"]]\nsns.kdeplot(in_term[\"adj.P.Val\"], label=\"In term\")\nout_term = ranks[~ranks[\"in_term\"]]\nsns.kdeplot(out_term[\"adj.P.Val\"], label=\"Not in term\")\nplt.xlabel(\"Rankings\")\nplt.legend()\nplt.show()\n</pre> in_term = ranks[ranks[\"in_term\"]] sns.kdeplot(in_term[\"adj.P.Val\"], label=\"In term\") out_term = ranks[~ranks[\"in_term\"]] sns.kdeplot(out_term[\"adj.P.Val\"], label=\"Not in term\") plt.xlabel(\"Rankings\") plt.legend() plt.show()"},{"location":"vignettes/#enrichment-vignette","title":"Enrichment vignette\u00b6","text":"<p>First, import required packages.</p>"}]}